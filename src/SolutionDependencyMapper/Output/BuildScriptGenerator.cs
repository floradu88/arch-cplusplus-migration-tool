using System.Text.Json;
using SolutionDependencyMapper.Models;
using SolutionDependencyMapper.Utils;

namespace SolutionDependencyMapper.Output;

/// <summary>
/// Generates layered build scripts for cross-platform builds.
/// </summary>
public class BuildScriptGenerator
{
    /// <summary>
    /// Generates all build script files (JSON, PowerShell, Batch, Shell).
    /// </summary>
    /// <param name="graph">The dependency graph with build layers</param>
    /// <param name="solutionPath">Path to the solution file (for determining relative paths)</param>
    /// <param name="outputDir">Directory where output files should be written</param>
    /// <param name="configuration">Build configuration (Debug, Release, etc.)</param>
    /// <param name="platform">Build platform (x64, x86, AnyCPU, etc.)</param>
    /// <param name="toolsContext">Optional tools context with discovered build tools</param>
    public static void GenerateAll(
        DependencyGraph graph,
        string solutionPath,
        string outputDir,
        string configuration = "Release",
        string platform = "x64",
        ToolsContext? toolsContext = null)
    {
        var solutionDir = Path.GetDirectoryName(solutionPath) ?? ".";
        
        // Generate JSON layers file
        var jsonPath = Path.Combine(outputDir, "build-layers.json");
        GenerateJsonLayers(graph, solutionDir, jsonPath);

        // Generate PowerShell script
        var ps1Path = Path.Combine(outputDir, "build.ps1");
        GeneratePowerShellScript(graph, solutionDir, ps1Path, configuration, platform, toolsContext);

        // Generate Batch script
        var batPath = Path.Combine(outputDir, "build.bat");
        GenerateBatchScript(graph, solutionDir, batPath, configuration, platform, toolsContext);

        // Generate Shell script (Linux/macOS)
        var shPath = Path.Combine(outputDir, "build.sh");
        GenerateShellScript(graph, solutionDir, shPath, configuration, toolsContext);
    }

    /// <summary>
    /// Generates JSON file with build layers structure.
    /// </summary>
    private static void GenerateJsonLayers(DependencyGraph graph, string solutionDir, string outputPath)
    {
        var layersData = new
        {
            Layers = graph.BuildLayers.Select(layer => new
            {
                Layer = layer.LayerNumber,
                Projects = layer.ProjectPaths
                    .Where(path => graph.Nodes.ContainsKey(path))
                    .Select(path =>
                    {
                        var project = graph.Nodes[path];
                        var relativePath = GetRelativePath(solutionDir, path);
                        return new
                        {
                            Name = project.Name,
                            Path = relativePath,
                            OutputType = project.OutputType
                        };
                    })
                    .ToList()
            })
            .ToList(),
            Cycles = graph.Cycles.Select(cycle => cycle.Select(path =>
            {
                var relativePath = GetRelativePath(solutionDir, path);
                return graph.Nodes.TryGetValue(path, out var project) 
                    ? new { Name = project.Name, Path = relativePath }
                    : new { Name = Path.GetFileNameWithoutExtension(path), Path = relativePath };
            }).ToList()).ToList()
        };

        var options = new JsonSerializerOptions
        {
            WriteIndented = true,
            PropertyNamingPolicy = JsonNamingPolicy.CamelCase
        };

        var json = JsonSerializer.Serialize(layersData, options);
        File.WriteAllText(outputPath, json);
    }

    /// <summary>
    /// Generates PowerShell build script.
    /// </summary>
    private static void GeneratePowerShellScript(
        DependencyGraph graph,
        string solutionDir,
        string outputPath,
        string configuration,
        string platform,
        ToolsContext? toolsContext = null)
    {
        var sb = new System.Text.StringBuilder();
        
        sb.AppendLine("#!/usr/bin/env pwsh");
        sb.AppendLine("# PowerShell build script generated by Solution Dependency Mapper");
        sb.AppendLine("$ErrorActionPreference = \"Stop\"");
        sb.AppendLine();
        sb.AppendLine("# Locate MSBuild");
        sb.AppendLine("$msbuild = $null");
        sb.AppendLine("if (Get-Command msbuild -ErrorAction SilentlyContinue) {");
        sb.AppendLine("    $msbuild = \"msbuild\"");
        sb.AppendLine("} else {");
        
        // Use discovered tools if available
        if (toolsContext != null && toolsContext.HasTool("msbuild.exe"))
        {
            var msbuildPaths = toolsContext.GetMSBuildPathsForScript();
            if (msbuildPaths.Count > 0)
            {
                sb.AppendLine("    # Using discovered MSBuild locations from tool discovery");
                sb.AppendLine("    $discoveredPaths = @(");
                foreach (var path in msbuildPaths)
                {
                    // Note: Backslashes do not need escaping in PowerShell quoted file paths.
                    sb.AppendLine($"        \"{path}\",");
                }
                sb.AppendLine("    )");
                sb.AppendLine("    foreach ($path in $discoveredPaths) {");
                sb.AppendLine("        if (Test-Path $path) {");
                sb.AppendLine("            $msbuild = $path");
                sb.AppendLine("            break");
                sb.AppendLine("        }");
                sb.AppendLine("    }");
            }
        }
        
        // Fallback to vswhere and common paths if no tools were discovered
        if (toolsContext == null || !toolsContext.HasTool("msbuild.exe"))
        {
            sb.AppendLine("    # Try to find MSBuild using vswhere (comes with Visual Studio)");
            sb.AppendLine("    $vswhere = \"${env:ProgramFiles(x86)}\\Microsoft Visual Studio\\Installer\\vswhere.exe\";");
            sb.AppendLine("    if (Test-Path $vswhere) {");
            sb.AppendLine("        $vsPath = & $vswhere -latest -requires Microsoft.Component.MSBuild -find MSBuild\\**\\Bin\\MSBuild.exe | Select-Object -First 1");
            sb.AppendLine("        if ($vsPath) {");
            sb.AppendLine("            $msbuild = $vsPath");
            sb.AppendLine("        }");
            sb.AppendLine("    }");
            sb.AppendLine("    ");
            sb.AppendLine("    # Fallback to common MSBuild locations");
            sb.AppendLine("    if (-not $msbuild) {");
            sb.AppendLine("        $commonPaths = @(");
            sb.AppendLine("            \"${env:ProgramFiles}\\Microsoft Visual Studio\\2026\\Enterprise\\MSBuild\\Current\\Bin\\MSBuild.exe\",");
            sb.AppendLine("            \"${env:ProgramFiles}\\Microsoft Visual Studio\\2026\\Professional\\MSBuild\\Current\\Bin\\MSBuild.exe\",");
            sb.AppendLine("            \"${env:ProgramFiles}\\Microsoft Visual Studio\\2026\\Community\\MSBuild\\Current\\Bin\\MSBuild.exe\",");
            sb.AppendLine("            \"${env:ProgramFiles}\\Microsoft Visual Studio\\2025\\Enterprise\\MSBuild\\Current\\Bin\\MSBuild.exe\",");
            sb.AppendLine("            \"${env:ProgramFiles}\\Microsoft Visual Studio\\2025\\Professional\\MSBuild\\Current\\Bin\\MSBuild.exe\",");
            sb.AppendLine("            \"${env:ProgramFiles}\\Microsoft Visual Studio\\2025\\Community\\MSBuild\\Current\\Bin\\MSBuild.exe\",");
            sb.AppendLine("            \"${env:ProgramFiles}\\Microsoft Visual Studio\\2022\\Enterprise\\MSBuild\\Current\\Bin\\MSBuild.exe\",");
            sb.AppendLine("            \"${env:ProgramFiles}\\Microsoft Visual Studio\\2022\\Professional\\MSBuild\\Current\\Bin\\MSBuild.exe\",");
            sb.AppendLine("            \"${env:ProgramFiles}\\Microsoft Visual Studio\\2022\\Community\\MSBuild\\Current\\Bin\\MSBuild.exe\",");
            sb.AppendLine("            \"${env:ProgramFiles(x86)}\\Microsoft Visual Studio\\2019\\Enterprise\\MSBuild\\Current\\Bin\\MSBuild.exe\",");
            sb.AppendLine("            \"${env:ProgramFiles(x86)}\\Microsoft Visual Studio\\2019\\Professional\\MSBuild\\Current\\Bin\\MSBuild.exe\",");
            sb.AppendLine("            \"${env:ProgramFiles(x86)}\\Microsoft Visual Studio\\2019\\Community\\MSBuild\\Current\\Bin\\MSBuild.exe\"");
            sb.AppendLine("        )");
            sb.AppendLine("        foreach ($path in $commonPaths) {");
            sb.AppendLine("            if (Test-Path $path) {");
            sb.AppendLine("                $msbuild = $path");
            sb.AppendLine("                break");
            sb.AppendLine("            }");
            sb.AppendLine("        }");
            sb.AppendLine("    }");
        }
        
        sb.AppendLine("}");
        sb.AppendLine();
        sb.AppendLine("if (-not $msbuild) {");
        sb.AppendLine("    Write-Error \"MSBuild not found. Please ensure Visual Studio or Build Tools are installed, or MSBuild is in your PATH.\"");
        sb.AppendLine("    Write-Error \"You can also run this script from a Developer Command Prompt for Visual Studio.\"");
        sb.AppendLine("    exit 1");
        sb.AppendLine("}");
        sb.AppendLine();
        sb.AppendLine("Write-Output \"=== Building Solution in Dependency Order ===\"");
        sb.AppendLine("Write-Output \"Configuration: " + configuration + "\"");
        sb.AppendLine("Write-Output \"Platform: " + platform + "\"");
        sb.AppendLine("Write-Output \"Using MSBuild: $msbuild\"");
        sb.AppendLine();

        foreach (var layer in graph.BuildLayers.OrderBy(l => l.LayerNumber))
        {
            var projectsInLayer = layer.ProjectPaths
                .Where(path => graph.Nodes.ContainsKey(path))
                .ToList();

            if (projectsInLayer.Count == 0)
                continue;

            sb.AppendLine($"Write-Output \"\"");
            sb.AppendLine($"Write-Output \"=== Layer {layer.LayerNumber} ===\"");
            
            foreach (var projectPath in projectsInLayer)
            {
                var project = graph.Nodes[projectPath];
                var relativePath = GetRelativePath(solutionDir, projectPath);
                var normalizedPath = relativePath.Replace('/', '\\');
                
                sb.AppendLine($"Write-Output \"  Building: {project.Name} ({project.OutputType})\"");
                sb.AppendLine($"& \"$msbuild\" \"{normalizedPath}\" /p:Configuration={configuration} /p:Platform={platform} /nologo /v:minimal");
                sb.AppendLine($"if ($LASTEXITCODE -ne 0) {{ Write-Error \"Build failed for {project.Name}\"; exit 1 }}");
            }
        }

        sb.AppendLine();
        sb.AppendLine("Write-Output \"\"");
        sb.AppendLine("Write-Output \"=== Build Complete ===\"");

        File.WriteAllText(outputPath, sb.ToString());
    }

    /// <summary>
    /// Generates Batch (CMD) build script.
    /// </summary>
    private static void GenerateBatchScript(
        DependencyGraph graph,
        string solutionDir,
        string outputPath,
        string configuration,
        string platform,
        ToolsContext? toolsContext = null)
    {
        var sb = new System.Text.StringBuilder();
        
        sb.AppendLine("@echo off");
        sb.AppendLine("REM Batch build script generated by Solution Dependency Mapper");
        sb.AppendLine("setlocal enabledelayedexpansion");
        sb.AppendLine();
        sb.AppendLine("REM Locate MSBuild");
        sb.AppendLine("set MSBUILD=");
        sb.AppendLine("where msbuild >nul 2>&1");
        sb.AppendLine("if %ERRORLEVEL% EQU 0 (");
        sb.AppendLine("    set MSBUILD=msbuild");
        sb.AppendLine("    goto :found");
        sb.AppendLine(") else (");
        
        // Use discovered tools if available
        if (toolsContext != null && toolsContext.HasTool("msbuild.exe"))
        {
            var msbuildPaths = toolsContext.GetMSBuildPathsForScript();
            if (msbuildPaths.Count > 0)
            {
                sb.AppendLine("    REM Using discovered MSBuild locations from tool discovery");
                foreach (var path in msbuildPaths)
                {
                    // Note: Backslashes do not need escaping in quoted file paths for CMD either.
                    sb.AppendLine($"    if exist \"{path}\" (");
                    sb.AppendLine($"        set MSBUILD={path}");
                    sb.AppendLine("        goto :found");
                    sb.AppendLine("    )");
                }
            }
        }
        
        // Fallback to vswhere and common paths if no tools were discovered
        if (toolsContext == null || !toolsContext.HasTool("msbuild.exe"))
        {
            sb.AppendLine("    REM Try to find MSBuild using vswhere");
            sb.AppendLine("    set VSWHERE=%ProgramFiles(x86)%\\Microsoft Visual Studio\\Installer\\vswhere.exe");
            sb.AppendLine("    if exist \"%VSWHERE%\" (");
            sb.AppendLine("        for /f \"usebackq tokens=*\" %%i in (`\"%VSWHERE%\" -latest -requires Microsoft.Component.MSBuild -find MSBuild\\**\\Bin\\MSBuild.exe`) do (");
            sb.AppendLine("            set MSBUILD=%%i");
            sb.AppendLine("            goto :found");
            sb.AppendLine("        )");
            sb.AppendLine("    )");
            sb.AppendLine("    ");
            sb.AppendLine("    REM Fallback to common MSBuild locations");
            sb.AppendLine("    if exist \"%ProgramFiles%\\Microsoft Visual Studio\\2026\\Enterprise\\MSBuild\\Current\\Bin\\MSBuild.exe\" (");
            sb.AppendLine("        set MSBUILD=%ProgramFiles%\\Microsoft Visual Studio\\2026\\Enterprise\\MSBuild\\Current\\Bin\\MSBuild.exe");
            sb.AppendLine("        goto :found");
            sb.AppendLine("    )");
            sb.AppendLine("    if exist \"%ProgramFiles%\\Microsoft Visual Studio\\2026\\Professional\\MSBuild\\Current\\Bin\\MSBuild.exe\" (");
            sb.AppendLine("        set MSBUILD=%ProgramFiles%\\Microsoft Visual Studio\\2026\\Professional\\MSBuild\\Current\\Bin\\MSBuild.exe");
            sb.AppendLine("        goto :found");
            sb.AppendLine("    )");
            sb.AppendLine("    if exist \"%ProgramFiles%\\Microsoft Visual Studio\\2026\\Community\\MSBuild\\Current\\Bin\\MSBuild.exe\" (");
            sb.AppendLine("        set MSBUILD=%ProgramFiles%\\Microsoft Visual Studio\\2026\\Community\\MSBuild\\Current\\Bin\\MSBuild.exe");
            sb.AppendLine("        goto :found");
            sb.AppendLine("    )");
            sb.AppendLine("    if exist \"%ProgramFiles%\\Microsoft Visual Studio\\2025\\Enterprise\\MSBuild\\Current\\Bin\\MSBuild.exe\" (");
            sb.AppendLine("        set MSBUILD=%ProgramFiles%\\Microsoft Visual Studio\\2025\\Enterprise\\MSBuild\\Current\\Bin\\MSBuild.exe");
            sb.AppendLine("        goto :found");
            sb.AppendLine("    )");
            sb.AppendLine("    if exist \"%ProgramFiles%\\Microsoft Visual Studio\\2025\\Professional\\MSBuild\\Current\\Bin\\MSBuild.exe\" (");
            sb.AppendLine("        set MSBUILD=%ProgramFiles%\\Microsoft Visual Studio\\2025\\Professional\\MSBuild\\Current\\Bin\\MSBuild.exe");
            sb.AppendLine("        goto :found");
            sb.AppendLine("    )");
            sb.AppendLine("    if exist \"%ProgramFiles%\\Microsoft Visual Studio\\2025\\Community\\MSBuild\\Current\\Bin\\MSBuild.exe\" (");
            sb.AppendLine("        set MSBUILD=%ProgramFiles%\\Microsoft Visual Studio\\2025\\Community\\MSBuild\\Current\\Bin\\MSBuild.exe");
            sb.AppendLine("        goto :found");
            sb.AppendLine("    )");
            sb.AppendLine("    if exist \"%ProgramFiles%\\Microsoft Visual Studio\\2022\\Enterprise\\MSBuild\\Current\\Bin\\MSBuild.exe\" (");
            sb.AppendLine("        set MSBUILD=%ProgramFiles%\\Microsoft Visual Studio\\2022\\Enterprise\\MSBuild\\Current\\Bin\\MSBuild.exe");
            sb.AppendLine("        goto :found");
            sb.AppendLine("    )");
            sb.AppendLine("    if exist \"%ProgramFiles%\\Microsoft Visual Studio\\2022\\Professional\\MSBuild\\Current\\Bin\\MSBuild.exe\" (");
            sb.AppendLine("        set MSBUILD=%ProgramFiles%\\Microsoft Visual Studio\\2022\\Professional\\MSBuild\\Current\\Bin\\MSBuild.exe");
            sb.AppendLine("        goto :found");
            sb.AppendLine("    )");
            sb.AppendLine("    if exist \"%ProgramFiles%\\Microsoft Visual Studio\\2022\\Community\\MSBuild\\Current\\Bin\\MSBuild.exe\" (");
            sb.AppendLine("        set MSBUILD=%ProgramFiles%\\Microsoft Visual Studio\\2022\\Community\\MSBuild\\Current\\Bin\\MSBuild.exe");
            sb.AppendLine("        goto :found");
            sb.AppendLine("    )");
            sb.AppendLine("    if exist \"%ProgramFiles(x86)%\\Microsoft Visual Studio\\2019\\Enterprise\\MSBuild\\Current\\Bin\\MSBuild.exe\" (");
            sb.AppendLine("        set MSBUILD=%ProgramFiles(x86)%\\Microsoft Visual Studio\\2019\\Enterprise\\MSBuild\\Current\\Bin\\MSBuild.exe");
            sb.AppendLine("        goto :found");
            sb.AppendLine("    )");
            sb.AppendLine("    if exist \"%ProgramFiles(x86)%\\Microsoft Visual Studio\\2019\\Professional\\MSBuild\\Current\\Bin\\MSBuild.exe\" (");
            sb.AppendLine("        set MSBUILD=%ProgramFiles(x86)%\\Microsoft Visual Studio\\2019\\Professional\\MSBuild\\Current\\Bin\\MSBuild.exe");
            sb.AppendLine("        goto :found");
            sb.AppendLine("    )");
            sb.AppendLine("    if exist \"%ProgramFiles(x86)%\\Microsoft Visual Studio\\2019\\Community\\MSBuild\\Current\\Bin\\MSBuild.exe\" (");
            sb.AppendLine("        set MSBUILD=%ProgramFiles(x86)%\\Microsoft Visual Studio\\2019\\Community\\MSBuild\\Current\\Bin\\MSBuild.exe");
            sb.AppendLine("        goto :found");
            sb.AppendLine("    )");
        }
        
        sb.AppendLine(")");
        sb.AppendLine(":found");
        sb.AppendLine();
        sb.AppendLine("if \"%MSBUILD%\"==\"\" (");
        sb.AppendLine("    echo ERROR: MSBuild not found.");
        sb.AppendLine("    echo Please ensure Visual Studio or Build Tools are installed, or MSBuild is in your PATH.");
        sb.AppendLine("    echo You can also run this script from a Developer Command Prompt for Visual Studio.");
        sb.AppendLine("    exit /b 1");
        sb.AppendLine(")");
        sb.AppendLine();
        sb.AppendLine("echo === Building Solution in Dependency Order ===");
        sb.AppendLine("echo Configuration: " + configuration);
        sb.AppendLine("echo Platform: " + platform);
        sb.AppendLine("echo Using MSBuild: %MSBUILD%");
        sb.AppendLine();

        foreach (var layer in graph.BuildLayers.OrderBy(l => l.LayerNumber))
        {
            var projectsInLayer = layer.ProjectPaths
                .Where(path => graph.Nodes.ContainsKey(path))
                .ToList();

            if (projectsInLayer.Count == 0)
                continue;

            sb.AppendLine("echo.");
            sb.AppendLine($"echo === Layer {layer.LayerNumber} ===");
            
            foreach (var projectPath in projectsInLayer)
            {
                var project = graph.Nodes[projectPath];
                var relativePath = GetRelativePath(solutionDir, projectPath);
                var normalizedPath = relativePath.Replace('/', '\\');
                
                sb.AppendLine($"echo   Building: {project.Name} ({project.OutputType})");
                sb.AppendLine($"\"%MSBUILD%\" \"{normalizedPath}\" /p:Configuration={configuration} /p:Platform={platform} /nologo /v:minimal");
                sb.AppendLine("if errorlevel 1 (");
                sb.AppendLine($"    echo ERROR: Build failed for {project.Name}");
                sb.AppendLine("    exit /b 1");
                sb.AppendLine(")");
            }
        }

        sb.AppendLine();
        sb.AppendLine("echo.");
        sb.AppendLine("echo === Build Complete ===");
        sb.AppendLine("exit /b 0");

        File.WriteAllText(outputPath, sb.ToString());
    }

    /// <summary>
    /// Generates Shell script for Linux/macOS (assumes CMake).
    /// </summary>
    private static void GenerateShellScript(
        DependencyGraph graph,
        string solutionDir,
        string outputPath,
        string configuration,
        ToolsContext? toolsContext = null)
    {
        var sb = new System.Text.StringBuilder();
        
        sb.AppendLine("#!/bin/bash");
        sb.AppendLine("# Shell build script generated by Solution Dependency Mapper");
        sb.AppendLine("set -e");
        sb.AppendLine();
        
        // Add CMake detection if tools were discovered
        if (toolsContext != null && toolsContext.HasTool("cmake.exe"))
        {
            var cmakePath = toolsContext.GetCmakePath();
            if (cmakePath != null)
            {
                // Convert Windows path to Unix-style if needed (for WSL scenarios)
                // Handle all drive letters (C:, D:, E:, etc.) and convert to WSL mount points
                var unixPath = cmakePath.Replace("\\", "/");
                
                // Check if path starts with a Windows drive letter (e.g., "C:", "D:")
                if (unixPath.Length >= 2 && char.IsLetter(unixPath[0]) && unixPath[1] == ':')
                {
                    var driveLetter = char.ToLower(unixPath[0]);
                    var pathAfterDrive = unixPath.Substring(2);
                    // Convert to WSL mount point format: C:\path -> /mnt/c/path
                    unixPath = $"/mnt/{driveLetter}{pathAfterDrive}";
                }
                
                sb.AppendLine("# Using discovered CMake (Windows path converted for WSL compatibility)");
                sb.AppendLine($"CMAKE=\"{unixPath}\"");
                sb.AppendLine("if [ ! -f \"$CMAKE\" ]; then");
                sb.AppendLine("    CMAKE=\"cmake\"  # Fallback to PATH");
                sb.AppendLine("fi");
                sb.AppendLine();
            }
        }
        
        sb.AppendLine("echo \"=== Building Solution in Dependency Order ===\"");
        sb.AppendLine("echo \"Configuration: " + configuration + "\"");
        sb.AppendLine();

        foreach (var layer in graph.BuildLayers.OrderBy(l => l.LayerNumber))
        {
            var projectsInLayer = layer.ProjectPaths
                .Where(path => graph.Nodes.ContainsKey(path))
                .ToList();

            if (projectsInLayer.Count == 0)
                continue;

            sb.AppendLine("echo \"\"");
            sb.AppendLine($"echo \"=== Layer {layer.LayerNumber} ===\"");
            
            foreach (var projectPath in projectsInLayer)
            {
                var project = graph.Nodes[projectPath];
                var relativePath = GetRelativePath(solutionDir, projectPath);
                var normalizedPath = relativePath.Replace('\\', '/');
                
                // For CMake, we use the project name as the target
                var targetName = project.Name;
                
                sb.AppendLine($"echo \"  Building: {project.Name} ({project.OutputType})\"");
                if (toolsContext != null && toolsContext.HasTool("cmake.exe"))
                {
                    sb.AppendLine("${CMAKE:-cmake} --build . --target " + targetName + " --config " + configuration);
                }
                else
                {
                    sb.AppendLine($"cmake --build . --target {targetName} --config {configuration}");
                }
            }
        }

        sb.AppendLine();
        sb.AppendLine("echo \"\"");
        sb.AppendLine("echo \"=== Build Complete ===\"");

        File.WriteAllText(outputPath, sb.ToString());
        
        // Make the script executable on Unix systems
        try
        {
            if (Environment.OSVersion.Platform == PlatformID.Unix || 
                Environment.OSVersion.Platform == PlatformID.MacOSX)
            {
                var process = new System.Diagnostics.Process
                {
                    StartInfo = new System.Diagnostics.ProcessStartInfo
                    {
                        FileName = "chmod",
                        Arguments = $"+x \"{outputPath}\"",
                        UseShellExecute = false,
                        CreateNoWindow = true
                    }
                };
                process.Start();
                process.WaitForExit();
            }
        }
        catch
        {
            // Ignore chmod errors on Windows
        }
    }

    /// <summary>
    /// Gets a relative path from base directory to target path.
    /// </summary>
    private static string GetRelativePath(string basePath, string targetPath)
    {
        try
        {
            var baseUri = new Uri(Path.GetFullPath(basePath) + Path.DirectorySeparatorChar);
            var targetUri = new Uri(Path.GetFullPath(targetPath));
            var relativeUri = baseUri.MakeRelativeUri(targetUri);
            var relativePath = Uri.UnescapeDataString(relativeUri.ToString());
            
            // Normalize path separators
            return relativePath.Replace('/', Path.DirectorySeparatorChar);
        }
        catch
        {
            // Fallback to just the filename if path resolution fails
            return Path.GetFileName(targetPath);
        }
    }
}

